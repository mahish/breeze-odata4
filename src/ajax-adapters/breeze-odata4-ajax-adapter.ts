import {
  AjaxAdapter,
  AjaxConfig,
  AutoGeneratedKeyType,
  DataProperty,
  DataType,
  Entity,
  EntityAspect,
  KeyMapping,
  SaveResult
} from 'breeze-client';
import { EntityErrorFromServer } from 'breeze-client/src/entity-manager';
import { AjaxRequest } from 'breeze-client/src/interface-registry';
import { Batch, Edmx } from 'ts-odatajs';

import { DataServiceSaveContext } from '../breeze-odata4-dataService-adapter';
import { ODataHttpClient } from '../odata-http-client';
import { Utilities } from '../utilities';

const ContentIdHeader = 'Content-ID';
const ContentTypeHeader = 'Content-Type';
const IfMatchHeader = 'If-Match';
const ODataVersionHeader = 'OData-Version';

/**
 * @classdesc OData4 ajax adapter, used for data saving in the @see OData4DataServiceAdapter
 */
export abstract class OData4AjaxAdapter implements AjaxAdapter {

  /**
   * Name the of OData4 ajax adapter
   */
  public abstract name: string;

  /**
   * Ajaxs odata4 ajax adapter
   * @param ajaxConfig The ajax config.
   * @param [httpClient] The http client.
   * @param [metadata] The metadata.
   */
  public abstract ajax(ajaxConfig: AjaxConfig, httpClient?: ODataHttpClient, metadata?: Edmx.Edmx): void;

  public _$impl?: any;

  /**
   * Check for recomposition of OData4 ajax adapter.
   */
  public checkForRecomposition?: (context: any) => void;

  public defaultSettings: { headers?: { [name: string]: string; }; } = {
    headers: {
      [ODataVersionHeader]: '4.0'
    }
  };

  public requestInterceptor?: (req: AjaxRequest) => void;

  /**
   * Initializes OData4 ajax adapter.
   */
  public initialize(): void { }

  /**
   * Creates the change request for the entity.
   * @param saveContext The save context.
   * @param entity The entity.
   * @param contentId The content id to provide to the server.
   * @returns The change request for the entity.
   */
  public createChangeRequest(saveContext: DataServiceSaveContext, entity: Entity, contentId: number): Batch.ChangeRequest {
    const aspect = entity.entityAspect;
    const entityManager = saveContext.entityManager;
    const helper = entityManager.helper;
    const routePrefix = saveContext.routePrefix;

    const result: Batch.ChangeRequest = {
      headers: {
        [ContentIdHeader]: contentId.toString(),
        [ContentTypeHeader]: 'application/json;IEEE754Compatible=true',
        ...this.defaultSettings?.headers
      },
      requestUri: null,
      method: null
    };

    saveContext.contentKeys[contentId] = entity;

    if (aspect.entityState.isAdded()) {
      result.requestUri = routePrefix + entity.entityType.defaultResourceName;
      result.method = 'POST';
      result.data = helper.unwrapInstance(entity, this.transformValue);
      saveContext.tempKeys[contentId] = aspect.getKey();
    } else if (aspect.entityState.isModified()) {
      this.updateDeleteMergeRequest(result, aspect, routePrefix);
      result.method = 'PATCH';
      result.data = helper.unwrapChangedValues(entity, entityManager.metadataStore, this.transformValue);
      // should be a PATCH/MERGE
    } else if (aspect.entityState.isDeleted()) {
      this.updateDeleteMergeRequest(result, aspect, routePrefix);
      result.method = 'DELETE';
    } else {
      return null;
    }

    return result;
  }

  /**
   * Prepares the save errors based on the resulting failed responses.
   * @param saveContext The save context.
   * @param failedResponses The failed responses after executing the batch request.
   * @returns The entity errors instances.
   */
  public prepareSaveErrors(saveContext: DataServiceSaveContext, failedResponses: Batch.FailedResponse[]): EntityErrorFromServer[] {
    const contentKeys = saveContext.contentKeys;

    const result = failedResponses
      .map(failedResponse => {
        const contentId = Number((failedResponse.response?.headers || {})[ContentIdHeader] ?? 0);

        const origEntity: Entity = contentKeys[contentId];
        if (!origEntity) {
          return;
        }

        const entityError = {
          entity: origEntity,
          entityTypeName: origEntity.entityType.name,
          errorMessage: Utilities.createError(failedResponse).message,
          errorName: null,
          keyValues: origEntity.entityAspect.getKey().values,
          propertyName: null
        } as EntityErrorFromServer;

        return entityError;
      })
      .filter(e => !!e);

    return result;
  }

  /**
   * Prepares the save result based on the resulting change responses.
   * @param saveContext The save context.
   * @param changeResponses The change responses after executing the batch request.
   * @returns The save result.
   */
  public prepareSaveResult(saveContext: DataServiceSaveContext, changeResponses: Batch.ChangeResponse[]): SaveResult {
    const tempKeys = saveContext.tempKeys;
    const contentKeys = saveContext.contentKeys;
    const entities: Entity[] = [];
    const keyMappings: KeyMapping[] = [];
    const result: SaveResult = { entities, keyMappings, deletedKeys: null };

    changeResponses.forEach(changeResponse => {
      // The server is required to provide the Content-ID header starting at 1, use 0 and effectively ignore it if not provided.
      const contentId = Number((changeResponse.headers || {})[ContentIdHeader] ?? 0);

      const origEntity = contentKeys[contentId];
      const rawEntity: Entity = changeResponse.data;
      if (rawEntity) {
        const tempKey = tempKeys[contentId];
        if (tempKey) {
          const entityType = tempKey.entityType;
          if (entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            const tempValue = tempKey.values[0];
            const realKey = entityType.getEntityKeyFromRawEntity(rawEntity, DataProperty.getRawValueFromServer);
            const keyMapping: KeyMapping = {
              entityTypeName: entityType.name,
              tempValue,
              realValue: realKey.values[0]
            };
            keyMappings.push(keyMapping);
          }
        }
        entities.push(rawEntity);
      } else if (origEntity) {
        entities.push(origEntity);
      }
    });

    return result;
  }

  /**
   * Transforms the value for the server.
   * @param prop The data property.
   * @param val The value of the property.
   * @returns The value to provide to the server.
   */
  protected transformValue(prop: DataProperty, val: any): any {
    // TODO: Split these into separate parsers
    if (prop.isUnmapped) {
      return undefined;
    }

    // TODO: Handle if dataType is a ComplexType
    if ((prop.dataType as DataType).quoteJsonOData) {
      val = val != null ? val.toString() : val;
    }

    return val;
  }

  /**
   * Configures the change request for an update or delete.
   * @param request The change request.
   * @param aspect The entity aspect.
   * @param routePrefix The route prefix.
   */
  protected updateDeleteMergeRequest(request: Batch.ChangeRequest, aspect: EntityAspect, routePrefix: string): void {
    const etagName = 'etag';
    const uriKeyName = 'uriKey';

    if (!aspect.extraMetadata) {
      aspect.extraMetadata = {};
    }

    const extraMetadata = aspect.extraMetadata;
    if (extraMetadata[etagName]) {
      request.headers[IfMatchHeader] = extraMetadata[etagName];
    }

    if (!extraMetadata[uriKeyName]) {
      extraMetadata[uriKeyName] = this.getUriKey(aspect);
    }

    const uriKey = extraMetadata[uriKeyName];
    request.requestUri =
      // use routePrefix if uriKey lacks protocol (i.e., relative uri)
      uriKey.indexOf('//') > 0 ? uriKey : routePrefix + uriKey;
  }

  // TODO: This could be made static
  private fmtProperty(prop: DataProperty, aspect: EntityAspect): any {
    // TODO: Handle if dataType is a ComplexType
    return (prop.dataType as DataType).fmtOData(aspect.getPropertyValue(prop.name));
  }

  private getUriKey(aspect: EntityAspect): string {
    const entityType = aspect.entity.entityType;
    const resourceName = entityType.defaultResourceName;
    const kps = entityType.keyProperties;

    const uriKeyValue = kps.length === 1
      ? this.fmtProperty(kps[0], aspect)
      : kps.map(kp => {
        return `${kp.nameOnServer}=${this.fmtProperty(kp, aspect)}`;
      });

    const uriKey = `${resourceName}(${uriKeyValue})`;

    return uriKey;
  }
}
